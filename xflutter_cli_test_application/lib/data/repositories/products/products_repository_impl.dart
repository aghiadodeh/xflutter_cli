// Generated By XFlutter Cli.
//
// more info: https://xflutter-cli.com
import 'package:dio/dio.dart';
import 'dart:async';
import 'package:injectable/injectable.dart';
import 'products_repository.dart';
import 'package:xflutter_cli_test_application/data/models/entities/product/product.dart';
import 'package:xflutter_cli_test_application/data/data_sources/remote/products/products_remote_data_source.dart';
import '../base_repository.dart';
import 'package:xflutter_cli_test_application/extensions/di_extension.dart';
import 'package:xflutter_cli_test_application/environments/environments.dart';
import 'package:xflutter_cli_test_application/data/models/responses/base_response/base_response.dart';
import 'package:xflutter_cli_test_application/data/models/responses/list_response/list_response.dart';
import 'package:xflutter_cli_test_application/data/data_sources/local/products/products_local_data_source.dart';
import 'package:xflutter_cli_test_application/data/models/local/product/local_product.dart';
import 'package:xflutter_cli_test_application/data/data_sources/local/products/queries/local_products_query_parameters.dart';

@LazySingleton(scope: 'products', as: ProductsRepository)
class ProductsRepositoryImpl extends BaseRepository implements ProductsRepository {
  final ProductsRemoteDataSource _remoteDataSource;
  final ProductsLocalDataSource _localDataSource;

  ProductsRepositoryImpl(this._remoteDataSource, this._localDataSource);

  @override
  Future<BaseResponse<Product>> create(Product data) async {
    final cancelToken = CancelToken();
    // send request to create item
    final response = await getResponse<Product>(
      () => _remoteDataSource.create(data: data.toJson(), cancelToken: cancelToken),
      cancelToken: cancelToken,
    );

    if (response.data != null) {
      // save item in the cache
      _localDataSource.insert(LocalProduct.fromEntity(response.data!));
    }

    return response;
  }

  @override
  Future<BaseResponse<Product>> update(int? id, Product data) async {
    final cancelToken = CancelToken();
    // send request to update item
    final response = await getResponse<Product>(
      () => _remoteDataSource.update(id: id, data: data.toJson(), cancelToken: cancelToken),
      cancelToken: cancelToken,
    );

    if (response.data != null) {
      // update item in the cache
      _localDataSource.insert(LocalProduct.fromEntity(response.data!));
    }

    return response;
  }

  @override
  Stream<BaseResponse<ListResponse<Product>>> findAll(int page) async* {
    final perPage = getIt<AppEnvironment>().perPage;
    // get cached data from local dataSource
    final cached = await _localDataSource.findAll(LocalProductsListQueryParameters(page: page, perPage: perPage));
    if (cached.isNotEmpty) {
      // emit cached data
      yield BaseResponse(
        success: true,
        data: ListResponse(data: cached.map((e) => e.fromLocal()).toList(), total: null, cached: true),
      );
    }

    // check internet connection
    if (isConnectingToInternet) {
      // fetch data from server
      final cancelToken = CancelToken();
      final response = await getResponse<ListResponse<Product>>(
        () => _remoteDataSource.findAll(page: page, perPage: perPage, cancelToken: cancelToken),
        cancelToken: cancelToken,
      );

      // emit fetched data
      yield response;

      // insert fetched data into cache
      if (response.data?.data != null) {
        await _localDataSource.insertAll(response.data!.data!.map((e) => LocalProduct.fromEntity(e)));
      }
    }
  }

  @override
  Stream<BaseResponse<Product>> findOne(int? id, {bool withCache = true}) async* {
    if (withCache) {
      // get item from cache
      final cached = await _localDataSource.findOne(LocalProductQueryParameters(id: id));
      if (cached != null) {
        yield BaseResponse(success: true, data: cached.fromLocal());
      }
    }

    // check internet connection
    if (isConnectingToInternet) {
      // get item from remote server
      final cancelToken = CancelToken();
      final response = await getResponse<Product>(
        () => _remoteDataSource.findOne(id: id, cancelToken: cancelToken),
        cancelToken: cancelToken,
      );

      // emit fetched data
      yield response;

      // update cache with new fetched data
      if (response.data != null) {
        await _localDataSource.insert(LocalProduct.fromEntity(response.data!));
      }
    }
  }

  @override
  Future<BaseResponse<dynamic>> delete(int? id) async {
    final cancelToken = CancelToken();
    final response = await getResponse<dynamic>(
      () => _remoteDataSource.delete(id: id, cancelToken: cancelToken),
      cancelToken: cancelToken,
    );

    // remove item from cache
    if (response.isSuccess) {
      await _localDataSource.delete(id);
    }

    return response;
  }
}
